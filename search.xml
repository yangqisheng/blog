<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java-ArrayList-源码分析（一）</title>
    <url>/2020/06/07/Java-ArrayList-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E4%B8%80/</url>
    <content><![CDATA[<p>ArrayList是数组实现的顺序表，是泛型Collection Framwork中的一员。本博文尝试分析一下ArrayList的源码，主要是弄懂实现背后的原理，搞清楚为什么要那么实现。为此，采用循序渐进，逐步深入的分析方式。</p>
<ul>
<li>先自己简单实现一遍</li>
<li>对照库的实现，挨个分析库为什么要那么写，那么写有什么好处。</li>
<li>库实现，涉及到哪些巧妙的方法。</li>
</ul>
<p>仔细分析起来，内容还是蛮多。为了不繁杂，博文可能需要分成多个部分，每个部分分析ArrayList中一簇功能。<br>本篇第一篇，先总体概览，再说说ArrayList Constructor。</p>
<span id="more"></span>

<h1 id="顺序表怎么实现"><a href="#顺序表怎么实现" class="headerlink" title="顺序表怎么实现"></a>顺序表怎么实现</h1><p>先考虑一下，如果不去看ArrayList的库实现，要自己写一个ArrayList，我们要怎么做。</p>
<h2 id="定义要实现的ArrayList功能。"><a href="#定义要实现的ArrayList功能。" class="headerlink" title="定义要实现的ArrayList功能。"></a>定义要实现的ArrayList功能。</h2><p>既然是个顺序表，所需功能大体离不开增删改查，再加上构造函数。</p>
<h3 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h3><ul>
<li>构造一个空的表。</li>
<li>构造一个有一定容量的表。</li>
<li>通过一个其它集合构造一个顺序表，将集合中元素挨个塞进顺序表。</li>
</ul>
<h3 id="增"><a href="#增" class="headerlink" title="增"></a>增</h3><p>顺序表增加的操作，一般来说，有：</p>
<ul>
<li>在末尾增加一个元素。</li>
<li>在某个位置增加一个元素。</li>
<li>将其它集合里面的元素批量增加到末尾。</li>
<li>将其它集合里面的元素批量增加到某个位置。</li>
</ul>
<h3 id="删"><a href="#删" class="headerlink" title="删"></a>删</h3><p>顺序表删除的操作，一般来说，有：</p>
<ul>
<li>删除某个位置上的元素。</li>
<li>删除一个位置区间内所有元素。</li>
<li>从顺序表中删除值为x的个元素。</li>
<li>删除所有元素， 即清空。</li>
</ul>
<h3 id="改"><a href="#改" class="headerlink" title="改"></a>改</h3><p>顺序表修改的操作，有：</p>
<ul>
<li>修改某个位置上的元素。</li>
</ul>
<h3 id="查"><a href="#查" class="headerlink" title="查"></a>查</h3><ul>
<li>获取某个位置上的元素。</li>
<li>查找某个元素在顺序表中的位置。</li>
<li>判断值为x的元素是否包含在顺序表中。</li>
</ul>
<h2 id="初步实现"><a href="#初步实现" class="headerlink" title="初步实现"></a>初步实现</h2><p>由于类功能较简单，我们就直接写代码原型。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package mypackage;</span><br><span class="line"></span><br><span class="line">public class MyArrayList&lt;E&gt; &#123;</span><br><span class="line">    private E[] elementData;</span><br><span class="line">    private int size;</span><br><span class="line">    </span><br><span class="line">    // 创建空的list</span><br><span class="line">    public MyArrayList() &#123;</span><br><span class="line">        elementData = new E[0];</span><br><span class="line">        size = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 创建一个容量为capacity的list，为什么需要这样一个初始容量的构造函数？</span><br><span class="line">    // 只提供默认空构造函数，然后调用增加元素方法进行内部数组申请，不也行么？</span><br><span class="line">    public MyArrayList(int capacity) &#123;</span><br><span class="line">        elementData = new E[capacity];</span><br><span class="line">        size = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 基于其它集合创建顺序表</span><br><span class="line">    public MyArrayList(MyArrayList&lt;E&gt; c) &#123;</span><br><span class="line">        System.arraycopy(c.elementData, 0, elementData, 0, c.size());</span><br><span class="line">        size = c.size();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 在末尾增加元素</span><br><span class="line">    public void add(E e) &#123;</span><br><span class="line">        if (elementData.length == size) &#123;</span><br><span class="line">            ensureCapacity(size + 1);</span><br><span class="line">        &#125;</span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 在某个位置增加元素，要判断参数合法性，如果不合法，是抛异常呢，还是返回错误值呢</span><br><span class="line">    public void add(int index, E e) &#123;</span><br><span class="line">        // check arguments,校验index是否 &lt; 0 或者 &gt; size</span><br><span class="line">        // ...</span><br><span class="line">        </span><br><span class="line">        if (elementData.length == size) &#123;</span><br><span class="line">            ensureCapacity(size + 1);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 将index及其后面的元素都往后错一位。System.arraycopy支持区间重叠拷贝。</span><br><span class="line">        System.arraycopy(...);</span><br><span class="line">        elementData[index] = e;</span><br><span class="line">        size += 1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 在某个位置增加另外一个集合内所有元素</span><br><span class="line">    public void add(int index, MyArrayList&lt;E&gt; c) &#123;</span><br><span class="line">        // check arguments</span><br><span class="line">        // ...</span><br><span class="line">        </span><br><span class="line">        if (elementData.length &lt; size + c.size()) &#123;</span><br><span class="line">            ensureCapacity(size + c.size());</span><br><span class="line">        &#125;</span><br><span class="line">        // 先将index往后的元素往后挪，为新元素腾开空位。</span><br><span class="line">        System.copyarray(...);</span><br><span class="line">        // 再讲c里面的元素copy过来</span><br><span class="line">        System.copyarray(...);</span><br><span class="line">        size += c.size();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 删除某个位置元素，如果产生不合法，是否要抛异常。</span><br><span class="line">    // 函数返回值为void是否可以？</span><br><span class="line">    public void remove(int index) &#123;</span><br><span class="line">        // check argument</span><br><span class="line">        // ...</span><br><span class="line">        </span><br><span class="line">        // 将index及其后面的元素往前移动一个位置, memmove操作。</span><br><span class="line">        // 从这里可以看到对于ArrayList，增加，删除操作是O(n)时间复杂度的。</span><br><span class="line">        System.copyarray(...); </span><br><span class="line">        size -= 1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 从集合内删除其它集合内的元素。</span><br><span class="line">    // ArrayList的实现，还有个boolean参数，控制开关，删除包含在c中的元素，还是删除不包含在c中的元素。</span><br><span class="line">    // 可以看做为控制两个集合之差的形式是 A - B 还是 B - A。 </span><br><span class="line">    public void remove(MyArrayList&lt;E&gt; c) &#123;</span><br><span class="line">        E[] newElementData = new E[elementData.length]</span><br><span class="line">        int r = 0;</span><br><span class="line">        int w = 0;</span><br><span class="line">        for (int r = 0; r &lt; size; ++r) &#123;</span><br><span class="line">            if (!c.contains(elementData[r])) &#123;</span><br><span class="line">                newElementData[w++] = elementData[r];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        elementData = newElementData;</span><br><span class="line">        size = w;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 修改某个位置元素值</span><br><span class="line">    public set(int index, E e) &#123;</span><br><span class="line">        // check argument</span><br><span class="line">        // ...</span><br><span class="line">        elementData[index] = e;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 查询</span><br><span class="line">    // 如果index不合法，抛异常。</span><br><span class="line">    public E get(int index) &#123;</span><br><span class="line">        // check argument</span><br><span class="line">        // ...</span><br><span class="line">        return elementData[index];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 查询某个元素所在位置</span><br><span class="line">    public int indexOf(E e) &#123;</span><br><span class="line">        for (int i = 0; i &lt; size; ++i) &#123;</span><br><span class="line">            if (elementData[i].equals(e)) &#123;</span><br><span class="line">                return i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 判断某元素是否在表中</span><br><span class="line">    public boolean contains(E e) &#123;</span><br><span class="line">        return indexOf(e) != -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="对比分析"><a href="#对比分析" class="headerlink" title="对比分析"></a>对比分析</h2><p>将自己写的初步实现代码与JDK中的ArrayList做比较，对每一簇功能细致的比较、分析，搞清楚JDK1.8实现的机理。下面主要讨论下JDK中ArrayList的构造方法，它们与自己实现的preliminary版本区别在哪。</p>
<h3 id="ArrayList构造方法"><a href="#ArrayList构造方法" class="headerlink" title="ArrayList构造方法"></a>ArrayList构造方法</h3><h4 id="ArrayList继承实现关系层次较深。"><a href="#ArrayList继承实现关系层次较深。" class="headerlink" title="ArrayList继承实现关系层次较深。"></a>ArrayList继承实现关系层次较深。</h4><p><a href="https://yangqisheng.github.io/images/ArrayList.png"><img src="https://yangqisheng.github.io/images/ArrayList.png" alt="img"></a></p>
<p>为什么要搞这么复杂的继承及实现关系呢，以后再说。先看几个问题：</p>
<ol>
<li><p>ArrayList extends AbstractList implements List, AbstractList其实已经implements List了，为什么ArrayList还要implements List?</p>
</li>
<li><p>看内部数组声明方式：transient Object[] elementData;<br>a. 为什么用Object[]类型，为什么不用 E[]呢？<br>b. 为什么用transient？<br>c. 为什么用包访问权限？<br>问题2.a，内部数组为什么要用Object[]，我没想明白。在stackoverflow上找到答案。Java里面不能创建泛型数组，编译通不过。看下面代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Container&lt;E&gt; &#123;</span><br><span class="line">    E[] arr = new E[3]; // 这里会有编译错误，error generic array creation</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么会这样？这和java的泛型实现有关，细节可以搜索相关资料。那不能用上面代码创建泛型数组，有其它方法吗？stackoverflow有人提出两种方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 方法1</span><br><span class="line">private Ojbect[] arr;</span><br><span class="line">arr = new Object[3];</span><br><span class="line"></span><br><span class="line">E get(int i) &#123;</span><br><span class="line">    return (E)arr[i]; // 每次获取元素都要转换类型，编译时会有unchecked的warning</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 方法2</span><br><span class="line">private E[] arr;</span><br><span class="line">arr = (E[]) new Object[3]; // 这里编译时会有unchecked的warning</span><br><span class="line"></span><br><span class="line">E get(int i) &#123;</span><br><span class="line">    return arr[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两者各有优缺点，java ArrayList是用的方法1。</p>
<p>问题2.b，内部数组为什么要用transient？我们知道transient是禁止字段进行序列化，ArrayList的数据就是保存在elementData数组中的，前面用transient标识，那还怎么对ArrayList进行序列化啊，是不是有点奇怪？我们来想一想，ArrayList内部elementData多数时候是有空余空间的，如果直接用默认序列化方法，那么这些空余空间也会被序列化进去，显然这是不合适的。我们只需要序列化真正的数据部分。于是ArrayList采用的方法是禁用默认序列化方法，重写了序列化和反序列化方法writeObject和readObject方法。</p>
<p>问题2.c，为什么用Default包访问权限，ArrayList自身的注释写着：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">transient Object[] elementData; // non-private to simplify nested class access</span><br></pre></td></tr></table></figure>

<p>简化嵌套类的访问。ArrayList内部有多个迭代器内部类，需要访问elementData。不过，经过我试验，Inner class是可以访问Outer class的private成员的。</p>
</li>
<li><p>基于其它集合构建ArrayList，函数签名中的参数有点怪，那是干什么用的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public MyArrayList(Collection&lt;? extends E&gt; c);</span><br></pre></td></tr></table></figure>

<p>意思是可以接收E类型元素组成的集合，以及E的子类型元素组成的集合。可能有人会觉得，E的子类型集合可以自动转换成E类型集合，就像子类型自动可以转换成它的父类型。<br>不可以的。看下面的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Fruit &#123;&#125;</span><br><span class="line">class Apple extends Furit &#123;&#125;</span><br><span class="line"></span><br><span class="line">Collection&lt;Furit&gt; c = new Collection&lt;&gt;();</span><br><span class="line">c.add(new Fruit());</span><br><span class="line">c.add(new Apple()); // 这是可以的，Apple对象自动转换成Fruit。因为Apple &quot;is-a&quot; Fruit</span><br><span class="line"></span><br><span class="line">/*******************************************************/</span><br><span class="line"></span><br><span class="line">Collection&lt;Fruit&gt; cf = new Collection&lt;&gt;();</span><br><span class="line">cf.add(new Apple());</span><br><span class="line"></span><br><span class="line">Collection &lt;Apple&gt; ca = new Collection&lt;&gt;();</span><br><span class="line">ca.add(new Apple);</span><br><span class="line"></span><br><span class="line">// 假如有个函数接收集合作为参数。下面的定义只能接收Collection&lt;Fruit&gt;的参数，</span><br><span class="line">// 不能接收Collection&lt;Apple&gt;的参数。也就是说：虽然Apple是Fruit，</span><br><span class="line">// 但是“装apple的篮子不是装Fruit的篮子”。</span><br><span class="line">void func(Collection&lt;Fruit&gt; c) &#123;</span><br><span class="line">    // do somethig</span><br><span class="line">&#125;</span><br><span class="line">func(cf); // 可以的。</span><br><span class="line">func(ca); // 不可以。因为 Collection&lt;Apple&gt; &quot;is-not-a&quot; Collection&lt;Fruit&gt;</span><br><span class="line"></span><br><span class="line">/*********有什么办法能让func也能接收Collection&lt;Apple&gt;********/</span><br><span class="line">// 这个函数参数的意思是：能接收所有Fruit及其子类组成的Collection。</span><br><span class="line">void func1(Collection&lt;? extends Fruit&gt;) &#123;</span><br><span class="line">    // do somethig</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里用到了Java泛型中的”通配符(Wildcards)“和”边界(Bounds)“概念。</p>
</li>
</ol>
<ul>
<li><? extends T> 是指”上界通配符“ (Upper Bounds Wildcards)</li>
<li><? super T> 是指”下界通配符“ (Lower Bounds Wildcards)
细节可以搜索相关资料。</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>stackoverflow <a href="https://stackoverflow.com/questions/13776576/why-does-the-arraylist-implementation-use-object">https://stackoverflow.com/questions/13776576/why-does-the-arraylist-implementation-use-object</a><br>知乎 <a href="https://www.zhihu.com/question/20400700">https://www.zhihu.com/question/20400700</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>ArrayList</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-ArrayList-源码分析（二）</title>
    <url>/2020/06/07/Java-ArrayList-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E4%BA%8C/</url>
    <content><![CDATA[<p>上一篇讲了ArrayList的几个构造函数。ArrayList的增删改查的实现，比较简单。本篇先讲一个代码效率问题，再着重讲讲ArrayList的迭代器实现。</p>
<span id="more"></span>

<h1 id="查询一个对象的索引位置"><a href="#查询一个对象的索引位置" class="headerlink" title="查询一个对象的索引位置"></a>查询一个对象的索引位置</h1><p>ArrayList的indexOf方法，接收一个Object，返回该Object在ArrayList中的位置。我们看下ArrayList的实现，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 写法一</span><br><span class="line">public int indexOf(Object o) &#123;</span><br><span class="line">    if (o == null) &#123;</span><br><span class="line">        for (int i = 0; i &lt; size; i++)</span><br><span class="line">            if (elementData[i]==null)</span><br><span class="line">                return i;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        for (int i = 0; i &lt; size; i++)</span><br><span class="line">            if (o.equals(elementData[i]))</span><br><span class="line">                return i;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到，它是先判断o是否为null，根据结果分别走两个分支，在分支里面用for循环去挨个判断elementData中元素是否等于o。初步看，代码里面好像for循环写了两个，重复了，我们也可以在一个for循环里面判断，写成下面这种形式:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 写法二</span><br><span class="line">public int indexOf(Object o) &#123;</span><br><span class="line">    for (int i = 0; i &lt; size; i++) &#123;</span><br><span class="line">        if (o == null) &#123;</span><br><span class="line">            if (elementData[i] == null)</span><br><span class="line">                return i;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (o.equals(elementData[i]))</span><br><span class="line">                return i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看起来，写法二比写法一少了一句for循环，但是写法二执行效率差一点，每次迭代都要判断一个o是否为null；而写法一只要判断一次o是否为null。所以总的下来，写法一节省了n/2 - 1次比较操作。</p>
<h1 id="迭代器和内部类"><a href="#迭代器和内部类" class="headerlink" title="迭代器和内部类"></a>迭代器和内部类</h1><p>ArrayList的迭代器是内部类实现的。迭代器是内部类的绝佳的应用场景。我们分几步来说明下：</p>
<ul>
<li>为什么要迭代器，不用迭代器，可不可以对ArrayList进行迭代。</li>
<li>迭代器不用内部类实现，用独立的类实现会怎样。</li>
</ul>
<h2 id="为什么要迭代器"><a href="#为什么要迭代器" class="headerlink" title="为什么要迭代器"></a>为什么要迭代器</h2><p>如果不用迭代器，也可以对ArrayList进行迭代。我们直接让ArrayList implements Iterator，增加一个成员变量来记录迭代的位置。这个时候ArrayList “is-a” Iterator。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class ArrayList&lt;E&gt; implements Iterator &#123;</span><br><span class="line">    private int next = 0; // index of the next element to return</span><br><span class="line"></span><br><span class="line">    // 其它成员</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">   boolean hasNext(); // 是否迭代到尾部</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">   E next();          // 返回当前元素，并且后移迭代位置</span><br><span class="line"></span><br><span class="line">   // 其它方法</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* client 对ArrayList进行迭代的时候是这样的 */</span><br><span class="line">ArrayList a = new ArrayList()</span><br><span class="line">// 对a进行了很多插入删除操作后</span><br><span class="line">while (a.hasNext()) &#123;</span><br><span class="line">    doSomething(a.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种实现方式会有什么问题？</p>
<ul>
<li>只支持单向迭代。</li>
<li>一次只支持一个迭代。如果想同时进行两个迭代（比如一个快的，一个慢的），不支持。</li>
</ul>
<h2 id="不用内部类，用单独的类实现"><a href="#不用内部类，用单独的类实现" class="headerlink" title="不用内部类，用单独的类实现"></a>不用内部类，用单独的类实现</h2><p>假如用单独的ArrayListIterator类实现，那么ArrayListIterator类一定要关联一个ArrayList。如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class ArrayListIterator&lt;E&gt; implements Iterator &#123;</span><br><span class="line">    private int next;     // index of the next element to return</span><br><span class="line">    private ArrayList&lt;E&gt; c; // 迭代器需要关联的集合</span><br><span class="line"></span><br><span class="line">    &lt;E&gt; ArrayListIterator(ArrayList&lt;E&gt; c) &#123;</span><br><span class="line">        next = 0;</span><br><span class="line">        this.c = c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    boolean hasNext() &#123;</span><br><span class="line">        return next != c.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    E next() &#123;</span><br><span class="line">        return c.get(next++)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你还可以实现一个逆向迭代器如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class ReverseArrayListIterator&lt;E&gt; implements Iterator &#123;</span><br><span class="line">    private int next;     // index of the next element to return</span><br><span class="line">    private ArrayList&lt;E&gt; c; // 迭代器需要关联的集合</span><br><span class="line"></span><br><span class="line">    &lt;E&gt; ReverseArrayListIterator(ArrayList&lt;E&gt; c) &#123;</span><br><span class="line">        next = c.size();</span><br><span class="line">        this.c = c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    boolean hasNext() &#123;</span><br><span class="line">        return next != -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    E next() &#123;</span><br><span class="line">        return c.get(next--);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这种方式，貌似解决了之前的“只能单向迭代”以及一次只能用一个迭代器两个问题。但是产生了新的问题：</p>
<ul>
<li>Iterator中的每个方法都要访问及操作内部集合的内部数据，但是都是通过Collection的public方法，不能直接操作Collection内部数据，不仅效率低，而且访问权限受限制。<br>这种实现方式，其实已经很接近内部类的实现方式了。内部类的实现方式解决了访问集合内部数据的限制问题。</li>
</ul>
<h2 id="看内部类的实现方法怎么表演"><a href="#看内部类的实现方法怎么表演" class="headerlink" title="看内部类的实现方法怎么表演"></a>看内部类的实现方法怎么表演</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class ArrayList&lt;E&gt; &#123;</span><br><span class="line">    Object[] elementData;</span><br><span class="line">    private int size;</span><br><span class="line">    // 其它成员及方法</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    class ListItr implements Iterator &#123;</span><br><span class="line">        private int next = 0;  // index of the next element to return</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        boolean hasNext() &#123;</span><br><span class="line">            return next == size; // 内部类可以直接访问外部类任何元素，包括成员和方法</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        E next() &#123;</span><br><span class="line">            return elementData[next++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Iterator iterator() &#123;</span><br><span class="line">        return new ListItr();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* Client 调用代码*/</span><br><span class="line">ArrayList&lt;String&gt; words = ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">// 插入删除一些String</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">Iterator itr = words.iterator();</span><br><span class="line">while (itr.hasNext()) &#123;</span><br><span class="line">    doSomething(itr.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内部类实现的优势：</p>
<ul>
<li>迭代器(内部类)可以直接访问集合(外部类)数据，效率高。</li>
<li>迭代器实现放在集合类内部，代码组织更好。</li>
<li>也可以在集合内部创建各种迭代器类。</li>
</ul>
<p>为什么内部类能够无障碍访问外部类元素，因为内部类有个隐藏的引用，指向外部类对象。通过这个引用就可以访问到外部类对象的元素。</p>
<h2 id="内部类杀手锏"><a href="#内部类杀手锏" class="headerlink" title="内部类杀手锏"></a>内部类杀手锏</h2><blockquote>
<p>如果没有内部类提供的、可以继承多个具体的或抽象的类的能力，一些设计与编程问题就很难解决。从这个角度看，内部类使得多重继承的解决方案变得完整。接口解决了部分问题，而内部类有效地实现了“多重继承”。也就是说，内部类允许继承多个非接口类型（类或抽象类）。</p>
</blockquote>
<p>我们知道Java中没有多继承，只有单继承多implements。有人可能会说，可以implements多个接口，不就相当于多继承吗？非也。接口中不能有成员变量，也就是说一个类，只能从一个父类继承成员变量。那有什么办法能让达到多继承的效果呢？用内部类。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">    private int i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B &#123;</span><br><span class="line">    private int j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class C extends A &#123;</span><br><span class="line">    B makeB() &#123;</span><br><span class="line">        // 返回匿名内部类</span><br><span class="line">        return new B() &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* Client 代码*/</span><br><span class="line">C c;</span><br><span class="line">B b = c.makeB(); // 这个b可以看做B的一个匿名子类的对象，同时它的内部又有一个隐藏的指向C对象的引用。C又是A的子类。</span><br></pre></td></tr></table></figure>

<p>通过这种方式，可以达到多继承的效果。细节可以参看 <em>Thinking in java On Java 8</em></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>Thinking in java on java 8</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>ArrayList</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>Python中的iterable和iterator</title>
    <url>/2020/06/07/Python%E4%B8%AD%E7%9A%84iterable%E5%92%8Citerator/</url>
    <content><![CDATA[<p>Python编程中，我们经常会遇到iterable和iterator的概念，二者之间既有区别又有联系。这篇博文就来详细说说这个话题。</p>
<span id="more"></span>

<h2 id="说在前面"><a href="#说在前面" class="headerlink" title="说在前面"></a>说在前面</h2><p>迭代器在各种编程语言中都是一个重要的概念。它是对一个对象或数据集合进行遍历的一种抽象。比如一个列表，一个字典，如果需要挨个打印里面的元素，我们就可以针对它们创建一个迭代器，然后就可以很方便的进行遍历了。</p>
<h2 id="Python的iterable和iterator"><a href="#Python的iterable和iterator" class="headerlink" title="Python的iterable和iterator"></a>Python的iterable和iterator</h2><p>Python中除了iterator对象还有iterable对象。我们知道iterator是迭代器，那iterable是个什么东西呢，它是可迭代对象。什么是可迭代对象？我理解就是可以利用迭代器对其进行遍历的东西。<br>Python中规定，只要类实现了__iter__方法并且该方法返回一个iterator的class就是iterable。</p>
<h2 id="iterable"><a href="#iterable" class="headerlink" title="iterable"></a>iterable</h2><p>Python中的list, dict,tuple等基本类型都是iterable，执行下面的python代码可以看到list对象有__iter__方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dir([1, 2, 3, 4,])</span><br></pre></td></tr></table></figure>

<p>下面我们构建一个自己的iterable,设定这个iterable基于一个字符串构建，切词形成一个可迭代的word集合，然后可以对里面的word进行迭代。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class MyIteratable:</span><br><span class="line">    def __init__(self, string):</span><br><span class="line">        self.string = string</span><br><span class="line"></span><br><span class="line">    # 这里要注意，返回一个iterator对象，利用这个iterator可以对该Myiterable进行迭代。</span><br><span class="line">    def __iter__(self):</span><br><span class="line">        return MyIterator(self.string)</span><br><span class="line"></span><br><span class="line">class MyIterator:</span><br><span class="line">    def __init__(self, string):</span><br><span class="line">        pass</span><br><span class="line">    def __next__(self):</span><br><span class="line">        pass</span><br></pre></td></tr></table></figure>

<p>client代码如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">my_iterable = MyIteratable(&quot;It&#x27;s a test&quot;)</span><br><span class="line"></span><br><span class="line"># iter(my_iterable)会自动调用my_iterable.__iter__方法。python类中带有双下划线前后缀的方法叫Magic Methods, 类似的还有__init__, __next__, __repr__等等。</span><br><span class="line">my_iterator = iter(my_iterable)</span><br><span class="line"></span><br><span class="line"># 下面就可以用my_iterator进行迭代了，具体怎么使用iterator进行迭代请看下面</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h2 id="iterator"><a href="#iterator" class="headerlink" title="iterator"></a>iterator</h2><p>Python中只要实现了__next__方法的class叫iterator（严格来说，还需要实现__iter__，这个后面再讲）。每调用一次next(iterator), 就取出了一个元素。当遍历完最后一个元素后，还调用next(iterator)就会触发StopIteration异常。所以我们利用一个iterator进行迭代时，就有client代码如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 通过iter(iterable)或者其它方法获取一个迭代器</span><br><span class="line">my_iterator = iter(iterable)</span><br><span class="line">while True:</span><br><span class="line">    try:</span><br><span class="line">        item = next(my_iterator) # 获取到一个元素</span><br><span class="line">    except StopIteration:</span><br><span class="line">        break</span><br></pre></td></tr></table></figure>

<p>next(my_iterator)其实是调用了my_iterator.__next__方法。这个方法每次都需要返回一个元素。接下来，我们来完善上面class MyIterator里面的方法。__next__方法每次返回一个元素，当到达尾部时触发StopIteration异常。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class MyIteratable:</span><br><span class="line">    def __init__(self, string):</span><br><span class="line">        self.string = string</span><br><span class="line"></span><br><span class="line">    # 这里要注意，返回一个iterator对象，利用这个iterator可以对该Myiterable进行迭代。</span><br><span class="line">    def __iter__(self):</span><br><span class="line">        return MyIterator(self.string)</span><br><span class="line"></span><br><span class="line">class MyIterator:</span><br><span class="line">    def __init__(self, string):</span><br><span class="line">        self.words = string.split()</span><br><span class="line">        self.index = 0 # 每次迭代，迭代器都有个位置。</span><br><span class="line"></span><br><span class="line">    def __next__(self):</span><br><span class="line">        if self.index &lt; len(self.words):</span><br><span class="line">            item = self.words[self.index]</span><br><span class="line">            self.index += 1</span><br><span class="line">            return item</span><br><span class="line">        else:</span><br><span class="line">            raise StopIteration()</span><br></pre></td></tr></table></figure>

<p>再次回到上面使用iterator迭代一个iterable的client代码，先要获取iterable的iterator，然后在while循环里面遍历元素，while里面退出条件是捕获到StopIteration异常。我们可以看到，对一个iterable进行迭代太啰嗦了，那么能否有个简洁的方法呢？有！请看下面：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for i in iterable:</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure>

<p>for in 语法就是对上面啰嗦写法的一个简写形式。for in是语言内部进行了上面那些啰嗦的操作。<br>好了，到现在，我们基本捋清了iterable和iterator的区别和联系了吧。总结如下：</p>
<ul>
<li>iterable是可迭代对象，实现了__iter__方法，该方法返回一个可以对自身进行迭代的迭代器。</li>
<li>iterator是迭代器对象，实现了__next__方法，可以对该迭代器所关联的iterable进行迭代。</li>
<li>iterable内部元素数量是可知的，而我们不能通过iterator知道其关联的iterable有多少数量，只能一步一步的next，最后触发StopIteration。</li>
</ul>
<h2 id="重要的一点-iterator也是一个iterable。"><a href="#重要的一点-iterator也是一个iterable。" class="headerlink" title="重要的一点, iterator也是一个iterable。"></a>重要的一点, iterator也是一个iterable。</h2><p>iterator还需要实现__iter__方法，而且该方法很简单就是返回自身，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class MyIterator:</span><br><span class="line">    def __init__(self, string):</span><br><span class="line">        self.words = string.split()</span><br><span class="line">        self.index = 0 # 每次迭代，迭代器都有个位置。</span><br><span class="line"></span><br><span class="line">    def __next__(self):</span><br><span class="line">        if self.index &lt; len(self.words):</span><br><span class="line">            item = self.words(self.index)</span><br><span class="line">            self.index += 1</span><br><span class="line">            return item</span><br><span class="line">        else:</span><br><span class="line">            raise StopIteration()</span><br><span class="line"></span><br><span class="line">    def __iter__(self):</span><br><span class="line">        return self</span><br></pre></td></tr></table></figure>

<p>iterator为什么要实现__iter__，而且大多数情况下都是返回self。是不是看起来很奇怪？如果没有这个__iter__函数，会不会有问题？这个问题我也是找了好多资料才想明白的。<br>情况是这样的，我们知道一个iterable可以应用在for in 语句中，更进一步，一个iterator也是可以应用在for in 语句中的。当应用在for in 中时，iterator就当做一个iterable使用了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">my_list = [1, 2, 3, 4]</span><br><span class="line">my_list_iter = iter(my_list)</span><br><span class="line">for i in my_list_iter:</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure>

<p>__iter__必须返回一个迭代器，而一个iterator的__iter__函数，它要返回一个迭代器，必然是它自身。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>Python 3 Object-oriented Programming, 2nd Edition</li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Iterable</tag>
        <tag>Iterator</tag>
      </tags>
  </entry>
  <entry>
    <title>Java SDK中Timer的分析</title>
    <url>/2020/06/08/java%E4%B8%ADTimer%E5%88%86%E6%9E%90_%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p>Java SDK的Timer是一个比较方便的定时器工具类，用来定时或周期性地执行用户提交的任务。其主要解决了简单的任务调度问题，让用户可以简单地提交和取消定时任务。同时Timer的线程安全性也保证了多个线程可以并发地对同一个任务进行调度和取消。</p>
<p>本博文尝试分析一下SDK中的Timer实现。大致从几个方面去介绍：</p>
<ol>
<li>What : Timer是什么，解决什么问题，怎么使用。</li>
<li>How&amp;Why : 内部是怎么实现的，为什么要那么实现。有哪些优点和局限。</li>
<li>When : 什么场景下适合使用Timer。</li>
</ol>
<h2 id="Timer是什么"><a href="#Timer是什么" class="headerlink" title="Timer是什么"></a>Timer是什么</h2><blockquote>
<p>A facility for threads to schedule tasks for future execution in a background thread. Tasks may be scheduled for one-time execution, or for repeated execution at regular intervals.</p>
</blockquote>
<p>Timer是JDK1.3引入的定时任务执行器。JDK文档说明了Timer是一个任务执行器，它可以在后台执行一次性或者周期性的任务。比如，我们在日常编码中，可能经常会碰到一个场景，需要定时清理缓存、日志，又或者有些场景需要周期性更新某个状态。那么Timer就是替我们做这些事情的。然而由于Timer的局限性，JDK1.5又引入了ScheduledThreadPoolExecutor，提供更稳定更精确且功能更多的定时执行器。</p>
<blockquote>
<p>Java 5.0 introduced the <code>java.util.concurrent</code> package and one of the concurrency utilities therein is the <a href="https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ScheduledThreadPoolExecutor.html"><code>ScheduledThreadPoolExecutor</code></a> which is a thread pool for repeatedly executing tasks at a given rate or delay. It is effectively a more versatile replacement for the <code>Timer</code>/<code>TimerTask</code> combination, as it allows multiple service threads, accepts various time units, and doesn’t require subclassing <code>TimerTask</code> (just implement <code>Runnable</code>). Configuring <code>ScheduledThreadPoolExecutor</code> with one thread makes it equivalent to <code>Timer</code>.</p>
</blockquote>
<span id="more"></span>

<h3 id="Timer的使用场景案例"><a href="#Timer的使用场景案例" class="headerlink" title="Timer的使用场景案例"></a>Timer的使用场景案例</h3><p>tomcat源码example中有个snake的示例程序。功能是使用websocket实现一个贪吃蛇的游戏。每隔100ms，程序需要更新贪吃蛇在屏幕中的位置。那么更新位置信息就可以设置成一个周期性任务。下面是snake程序的代码片段。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SnakeTimer</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Timer gameTimer = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> TICK_DELAY = <span class="number">100</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 启动定时执行器</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startTimer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个定时执行器</span></span><br><span class="line">    gameTimer = <span class="keyword">new</span> Timer(SnakeTimer.class.getSimpleName() + <span class="string">&quot; Timer&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 向定时执行器提交一个周期性任务。</span></span><br><span class="line">    gameTimer.scheduleAtFixedRate(<span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                tick();  <span class="comment">// 更新位置信息</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;Caught to prevent timer from shutting down&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, TICK_DELAY, TICK_DELAY);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">      <span class="keyword">for</span> (Iterator&lt;Snake&gt; iterator = SnakeTimer.getSnakes().iterator();</span><br><span class="line">              iterator.hasNext();) &#123;</span><br><span class="line">          Snake snake = iterator.next();</span><br><span class="line">          snake.update(SnakeTimer.getSnakes());</span><br><span class="line">          sb.append(snake.getLocationsJson());</span><br><span class="line">          <span class="keyword">if</span> (iterator.hasNext()) &#123;</span><br><span class="line">              sb.append(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      broadcast(String.format(<span class="string">&quot;&#123;\&quot;type\&quot;: \&quot;update\&quot;, \&quot;data\&quot; : [%s]&#125;&quot;</span>,</span><br><span class="line">              sb.toString()));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">stopTimer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (gameTimer != <span class="keyword">null</span>) &#123;</span><br><span class="line">          gameTimer.cancel();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用Timer比较简单，创建一个Timer，然后向Timer提交一个任务。Timer后台线程会在指定的时间自动执行任务。向Timer提交任务主要有两个方法。<code>schedule</code>和<code>scheduleAtFixedRate</code>，一个是提交一次性任务，一个是提交周期性任务。</p>
<h2 id="Timer内部的实现"><a href="#Timer内部的实现" class="headerlink" title="Timer内部的实现"></a>Timer内部的实现</h2><h3 id="几个内部组件"><a href="#几个内部组件" class="headerlink" title="几个内部组件"></a>几个内部组件</h3><p>根据Timer所要实现的功能需求，大致可以分解出几个组件。</p>
<ol>
<li><p>Task，用户提交的任务，想要Timer替我们执行任务，用户得创建一个Task，也就是这个Task得implements Runnable。与Timer协同的任务是TimerTask抽象类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">TimerTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用户任务UserTask需要extends TimerTask，实现run函数，将任务所需要做的事情和访问的资源统一在run函数里面实现。TimerTask需要有个任务状态的标识，标识这个任务处于什么状态，待运行、正在运行、被取消、执行完成。另外，TimerTask还需要有个标识来记录这个Task是一次性的还是周期执行的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">TimerTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> state = VIRGIN; <span class="comment">// 任务状态。没有用enum,为什么</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> VIRGIN = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SCHEDULED = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXECUTED = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED = <span class="number">3</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">long</span> nextExecutionTime; <span class="comment">// 下一次执行的时间戳，Timer中小顶堆队列是按照task的这个属性进行比较大小</span></span><br><span class="line">  <span class="keyword">long</span> period = <span class="number">0</span>; <span class="comment">// 任务执行周期，0表示一次性任务</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Timer, 任务执行器。任务执行器执行用户提交的任务，显然需要一个队列来保存任务，同时需要一个内部线程来执行任务。队列中存放的是待运行的任务，这些任务都有个属性，nextExecutionTime下一次运行的时间戳。内部线程在while(true)循环里面执行逻辑：从队列中找出时间戳最近的任务，如果当前时间戳已经达到或超过任务运行时间戳，就执行task.run()来执行任务，对于周期性任务还会将下一次执行的任务实例再次插入队列。这里涉及到几个问题：a. 任务队列用什么数据结构，由于内部线程每次只需要取一个最近时间的任务，容易想到堆或者优先队列。SDK Timer内部使用数组实现的小顶堆。b. 内部线程在没有任务执行或者堆顶任务运行时间还没有到的时候，不能耗费CPU，需要阻塞wait，等待其它用户线程来唤醒或者自己等到一段时间再run。c. 用户任务，Timer内部队列需要线程安全。用户任务为什么需要线程安全？可能用户线程A提交后，用户线程B由于某种原因需要提前终止它。而对于Timer内部队列，可能会有多个用户线程往Timer提交任务，所以也得是线程安全的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Timer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TaskQueue queue = <span class="keyword">new</span> TaskQueue(); <span class="comment">// 内部任务队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TimerThread thread = <span class="keyword">new</span> TimerThread(queue); <span class="comment">// 内部执行线程</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger nextSerialNumber = <span class="keyword">new</span> AtoicInteger(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面代码可以看出，每个Timer的实例都有一个内部线程和队列。Timer实例对其内部线程进行了编号。</p>
</li>
<li><p>TaskQueue，任务队列，是Timer的内部类，就是一个数组实现的小顶堆。TaskQueue内部没有锁，它的线程安全性是由Timer在访问TaskQueue的时候加锁。</p>
</li>
<li><p>TaskThread，任务线程，也是Timer的内部类。由于TaskThread需要访问TaskQueue，所以在TaskThread构造的时候将Timer的TaskQueue注入进去了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">       mainLoop();</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       <span class="keyword">synchronized</span>(queue) &#123;</span><br><span class="line">         newTaskMayBeScheduled = <span class="keyword">false</span>;</span><br><span class="line">         queue.clear();</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mainLoop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimerTask task;</span><br><span class="line">            <span class="keyword">boolean</span> taskFired;</span><br><span class="line">            <span class="keyword">synchronized</span>(queue) &#123;</span><br><span class="line">                <span class="comment">// Wait for queue to become non-empty</span></span><br><span class="line">                <span class="keyword">while</span> (queue.isEmpty() &amp;&amp; newTasksMayBeScheduled)</span><br><span class="line">                    queue.wait();</span><br><span class="line">                <span class="keyword">if</span> (queue.isEmpty())</span><br><span class="line">                    <span class="keyword">break</span>; <span class="comment">// Queue is empty and will forever remain; die</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// Queue nonempty; look at first evt and do the right thing</span></span><br><span class="line">                <span class="keyword">long</span> currentTime, executionTime;</span><br><span class="line">                task = queue.getMin();</span><br><span class="line">                <span class="keyword">synchronized</span>(task.lock) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (task.state == TimerTask.CANCELLED) &#123;</span><br><span class="line">                        queue.removeMin();</span><br><span class="line">                        <span class="keyword">continue</span>;  <span class="comment">// No action required, poll queue again</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    currentTime = System.currentTimeMillis();</span><br><span class="line">                    executionTime = task.nextExecutionTime;</span><br><span class="line">                    <span class="keyword">if</span> (taskFired = (executionTime&lt;=currentTime)) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (task.period == <span class="number">0</span>) &#123; <span class="comment">// Non-repeating, remove</span></span><br><span class="line">                            queue.removeMin();</span><br><span class="line">                            task.state = TimerTask.EXECUTED;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123; <span class="comment">// Repeating task, reschedule</span></span><br><span class="line">                            queue.rescheduleMin(</span><br><span class="line">                              task.period&lt;<span class="number">0</span> ? currentTime   - task.period</span><br><span class="line">                                            : executionTime + task.period);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!taskFired) <span class="comment">// Task hasn&#x27;t yet fired; wait</span></span><br><span class="line">                    queue.wait(executionTime - currentTime);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (taskFired)  <span class="comment">// Task fired; run it, holding no locks</span></span><br><span class="line">                task.run();</span><br><span class="line">        &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来看看<code>TimerThread.run()</code>的实现。就一个mainLoop循环。外面用try包裹一下，有个finally块负责清理queue。我们看mainLoop是不会抛异常的(queue.wait可能会抛的InterruptedException被mainLoop内部catch住了，task.run也不会抛异常)，为什么TimerThread.run里面要将mainLoop包在try finally块里面呢？原因在于：虽然TimerThread本身在执行mainLoop时不会抛InterruptedExecption，但是外部用户线程可以向TimerThread发送中断信号，于是mainLoop得用try finally块包裹一下。还有一个<strong>重要的原因</strong>，如果运行的UserTimerTask遇到了unchecked exception，那么就会进入到finally块里，将这个Timer设置成terminate状态了。这也是Timer的一个局限。</p>
<p>下面是一个概要图。</p>
<p><img src="https://dzmiba.com/Timer.jpg" alt="Timer"></p>
</li>
</ol>
<h3 id="优点和局限"><a href="#优点和局限" class="headerlink" title="优点和局限"></a>优点和局限</h3><p>Timer的优点：</p>
<ol>
<li>实现简单，使用起来也很简单。</li>
<li>轻量级，不需要很多系统资源，只有一个后台线程和一个内部任务数组。支持取消任务。</li>
<li>线程安全。Timer内部执行任务是线程安全的。多个线程可以同时使用同一个Timer实例。用户任务自身的线程安全性由用户保证。</li>
</ol>
<p>Timer的局限：</p>
<ol>
<li>无法保证一个任务在精确的时间执行。由于Timer内部只有一个线程去执行任务，假如线程在执行某个任务过程中耗费了太多时间，或者卡住了，那么Timer内部队列里面的任务都会受到影响，因为从内部队列中取任务的也是这个内部线程。它卡住了，就不能保证队列中的任务在预期的时间被取出来执行。所以执行时间比较短的轻量级定时task比较适合使用Timer。</li>
<li>如果某个UserTimeTask运行时出现unchecked exception(比如运行时异常)，那么当前的Timer实例会马上变成terminated状态（就像外部调用了timer.cancel()）。某本书里称这种情况叫“thread leaking”。如果此时再往timer里面提交任务，会触发IllegalStateException: Timer already cancelled。</li>
</ol>
<h2 id="Timer内部实现的一些分析"><a href="#Timer内部实现的一些分析" class="headerlink" title="Timer内部实现的一些分析"></a>Timer内部实现的一些分析</h2><h3 id="Timer内部线程安全性"><a href="#Timer内部线程安全性" class="headerlink" title="Timer内部线程安全性"></a>Timer内部线程安全性</h3><h4 id="内部queue的线程安全性"><a href="#内部queue的线程安全性" class="headerlink" title="内部queue的线程安全性"></a>内部queue的线程安全性</h4><p>外部用户向Timer提交任务时，Timer需要将任务加到内部queue中，同时Timer内部thread需要从queue中取出任务执行，这里有race condition，queue必须要加锁。所以内部线程while循环里面，对queue的访问，使用了<code>synchronized(queue)</code>。外部线程调用schedule或者scheduleAtFixedRate时，同样也使用了<code>synchronized(queue)</code>。外部线程调用cancel时，需要清空queue，也一样使用了同步锁。</p>
<h4 id="Timer内部循环线程对Task也加锁"><a href="#Timer内部循环线程对Task也加锁" class="headerlink" title="Timer内部循环线程对Task也加锁"></a>Timer内部循环线程对Task也加锁</h4><p>从上面Timer内部mainLoop代码中看到，内部线程从queue中取出<strong>最小任务</strong>后，使用了<code>synchronized(task.lock)</code>来修改task的数据，包括修改task.state, 将task重新放回queue。为什么要对task锁一下呢。主要是因为，在task放入Timer之后，可能有用户线程对task执行cancel操作，修改task.state。看下面TimerTask.cancel方法，也加锁了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(lock) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> result = (state == SCHEDULED);</span><br><span class="line">        state = CANCELLED;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="TimerThread-newTaskMayBeScheduled起什么作用"><a href="#TimerThread-newTaskMayBeScheduled起什么作用" class="headerlink" title="TimerThread.newTaskMayBeScheduled起什么作用"></a>TimerThread.newTaskMayBeScheduled起什么作用</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">```java</span><br><span class="line">/**</span><br><span class="line">Terminates this timer, discarding any currently scheduled tasks. Does not interfere with a currently executing task (if it exists). Once a timer has been terminated, its execution thread terminates gracefully, and no more tasks may be scheduled on it.</span><br><span class="line">Note that calling this method from within the run method of a timer task that was invoked by this timer absolutely guarantees that the ongoing task execution is the last task execution that will ever be performed by this timer.</span><br><span class="line">This method may be called repeatedly; the second and subsequent calls have no effect.</span><br><span class="line">*/</span><br><span class="line">public void cancel() &#123;</span><br><span class="line">    synchronized(queue) &#123;</span><br><span class="line">        thread.newTasksMayBeScheduled = false;</span><br><span class="line">        queue.clear();</span><br><span class="line">        queue.notify();  // In case queue was already empty.</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后一行代码，queue.notify()起什么作用？注释说”In case queue was already empty”是什么意思？这是为了确保TimerThread停止下来。再回到TimerThread.mainLoop代码，可以看到，如果外部线程调用Timer.cancel时，TimerThread正在执行任务，当任务执行完成后，mainLoop会终止下来。但是如果当外部Timer.cancel时，queue已经空了，TimerThread阻塞在<code>queue.wait()</code>上，这个时候Timer.cancel不调用<code>queue.notify()</code>，TimerThread将永远阻塞在那里，不能终止。</p>
<h3 id="schedule还是scheduleAtFixedRate"><a href="#schedule还是scheduleAtFixedRate" class="headerlink" title="schedule还是scheduleAtFixedRate?"></a>schedule还是scheduleAtFixedRate?</h3><p>向Timer提交周期性任务的时候，是使用schedule还是scheduleAtFixedRate。有本书里，称schedule是schedule at fixed delay，和scheduleAtFixedRate对应。那到底是什么是fixed dealy，什么是fixed rate呢？举一个例子，假如我现在有一个周期任务A，自身运行时间很短，希望这个任务每10s运行一次；又有一个一次性任务B，运行时间是40s。按照下面的代码提交任务，运行情况是怎么样呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Timer timer = <span class="keyword">new</span> Timer();</span><br><span class="line"></span><br><span class="line">timer.schedule(B, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">// 提交一次性任务B，B运行时间40s</span></span><br><span class="line">timer.schedule(A, <span class="number">0</span>, <span class="number">10</span>*<span class="number">1000</span>); <span class="comment">// 提交周期性任务，每10s运行一次。以fixed delay方式，</span></span><br></pre></td></tr></table></figure>

<p>fix delay是指一个任务被延误执行后，不管之前错过了多少次执行，继续以固定的delay时间（这里就是10s）执行后续任务实例。如下图：</p>
<p><img src="https://dzmiba.com/fixed_delay.jpg" alt="fixed_rate"></p>
<p>再看下面以fixed rate方式提交任务的代码，以及运行情况</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Timer timer = <span class="keyword">new</span> Timer();</span><br><span class="line"></span><br><span class="line">timer.schedule(B, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">// 提交一次性任务B，B运行时间40s</span></span><br><span class="line">timer.scheduleAtFixedRate(A, <span class="number">0</span>, <span class="number">10</span>*<span class="number">1000</span>); <span class="comment">// 提交周期性任务，每10s运行一次。以fixed rate方式，</span></span><br></pre></td></tr></table></figure>

<p><img src="https://dzmiba.com/fixed_rate.jpg" alt="fixed_rate"></p>
<p>我们可以看到fixed rate方式，当一个任务被延误后，它在后面会把延误的执行次数给补上。这种方式，可能会出现一种情况：一个被延误执行的任务，在某个时间连续执行多次。</p>
<p>上面两种方式具体是怎么实现的呢？jdk Timer里面用了一个比较巧妙的方式，看代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mainLoop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimerTask task;</span><br><span class="line">                <span class="keyword">boolean</span> taskFired;</span><br><span class="line">                <span class="keyword">synchronized</span>(queue) &#123;</span><br><span class="line">                    <span class="comment">// Wait for queue to become non-empty</span></span><br><span class="line">                    <span class="keyword">while</span> (queue.isEmpty() &amp;&amp; newTasksMayBeScheduled)</span><br><span class="line">                        queue.wait();</span><br><span class="line">                    <span class="keyword">if</span> (queue.isEmpty())</span><br><span class="line">                        <span class="keyword">break</span>; <span class="comment">// Queue is empty and will forever remain; die</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Queue nonempty; look at first evt and do the right thing</span></span><br><span class="line">                    <span class="keyword">long</span> currentTime, executionTime;</span><br><span class="line">                    task = queue.getMin();</span><br><span class="line">                    <span class="keyword">synchronized</span>(task.lock) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (task.state == TimerTask.CANCELLED) &#123;</span><br><span class="line">                            queue.removeMin();</span><br><span class="line">                            <span class="keyword">continue</span>;  <span class="comment">// No action required, poll queue again</span></span><br><span class="line">                        &#125;</span><br><span class="line">                        currentTime = System.currentTimeMillis();</span><br><span class="line">                        executionTime = task.nextExecutionTime;</span><br><span class="line">                        <span class="keyword">if</span> (taskFired = (executionTime&lt;=currentTime)) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (task.period == <span class="number">0</span>) &#123; <span class="comment">// Non-repeating, remove</span></span><br><span class="line">                                queue.removeMin();</span><br><span class="line">                                task.state = TimerTask.EXECUTED;</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123; <span class="comment">// Repeating task, reschedule</span></span><br><span class="line">                                queue.rescheduleMin(</span><br><span class="line">                                  task.period&lt;<span class="number">0</span> ? currentTime   - task.period</span><br><span class="line">                                                : executionTime + task.period);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (!taskFired) <span class="comment">// Task hasn&#x27;t yet fired; wait</span></span><br><span class="line">                        queue.wait(executionTime - currentTime);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (taskFired)  <span class="comment">// Task fired; run it, holding no locks</span></span><br><span class="line">                    task.run();</span><br><span class="line">            &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>还是Timer.mainLoop代码，秘密就在<code>task.period &lt; 0 ? currentTime - task.period : executionTime + task.period</code>这里。当使用schedule提交周期任务时，这个任务的period被取反成负数了，下一次执行的时间是<strong>当前时间</strong> + 任务本身的period，如果某一次任务执行被延误了，那么后续的执行依次顺延；而使用scheduleAtFixedRate提交周期任务时，下一次执行的时间是“当前任务<strong>预期执行时间</strong> + 任务本身的period”，即使某次任务真正的执行时间被延误了，随后的执行时间还是“预期执行时间 + 任务本身的period”。</p>
<h2 id="Timer使用场景"><a href="#Timer使用场景" class="headerlink" title="Timer使用场景"></a>Timer使用场景</h2><p>Timer是Java SDK1.3引入的，SDK1.5时引入了ScheduledThreadPoolExecutor更能更强大，也更稳定，更精确。大多数时候，应该使用ScheduledThreadPoolExecutor。Timer优势在于使用简单，轻量级，比较适合轻量级任务且精度要求不高的场景，比如周期性发送心跳包，周期性清理缓存，周期性更新状态。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Timer</tag>
        <tag>JDK源码</tag>
      </tags>
  </entry>
  <entry>
    <title>Java SDK中线程池系列（一）---- Executor</title>
    <url>/2020/06/09/java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<p>JDK中Executor是一个interface，只有一个方法<code>void execute(Runnable r)</code>，是一个执行器，<code>execute</code>方法用了执行一个Runnable任务。这个方法是异步还是同步的，没有要求。Executor存在的目的是提供一种方式将任务的提交和任务的执行解耦。下面是对应的Java Doc说明。</p>
<blockquote>
<p>An object that executes submitted Runnable tasks. This interface provides a way of decoupling task submission from the mechanics of how each task will be run, including details of thread use, scheduling, etc. An Executor is normally used instead of explicitly creating threads. For example, rather than invoking new Thread(new RunnableTask()).start() for each of a set of tasks, you might use:<br>  Executor executor = anExecutor(); </p>
<p>  executor.execute(new RunnableTask1());</p>
<p>  executor.execute(new RunnableTask2());</p>
</blockquote>
<p>本博文循序渐进地介绍几种文档中说明的Executor实现，帮助理解Executor。为后面的线程池内容做铺垫。</p>
<span id="more"></span>

<h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p><img src="https://dzmiba.com/executor.jpg" alt="Executor"></p>
<h2 id="DirectExecutor"><a href="#DirectExecutor" class="headerlink" title="DirectExecutor"></a>DirectExecutor</h2><p>DirectExecutor是最简单的Executor实现，外部线程调用<code>DirectExecutor.execute(r)</code>时是其自身调用<code>r.run()</code></p>
<p>如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DirectExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">        r.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">Test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Executor executor = <span class="keyword">new</span> DirectExecutor();</span><br><span class="line">        Runnable r = () -&gt; System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        executor.execute(r); <span class="comment">// 相当于r.run();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DirectExecutor.execute是同步的，没什么实际用途，只是一个demo。</p>
<h2 id="ThreadPerTaskExecutor"><a href="#ThreadPerTaskExecutor" class="headerlink" title="ThreadPerTaskExecutor"></a>ThreadPerTaskExecutor</h2><p>ThreadPerTaskExecutor是一个独立线程执行器，用户给它提交任务时，它内部为每个任务spawn一个新的线程来执行任务。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadPerTaskExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(r).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种Executor是异步的，外部线程调用execute后马上返回。缺点是：如果任务运行开销相对创建及销毁线程的开销很小，这种方式就很不值当。</p>
<h2 id="SerialExecutor"><a href="#SerialExecutor" class="headerlink" title="SerialExecutor"></a>SerialExecutor</h2><p>SerialExecutor是一个串行Executor，它限定了一个Executor执行task的顺序，至于Executor怎么执行任务，不关心，委托给其它Executor。它只是在某个Executor执行task时增加了串行的约束。这种情况，和Java IO里面的InputStream/OutputStream有点像，某种Stream需要缓存时，就套一层buffer。代理模式呼之欲出了。<code>SerialExecutor</code>使用了代理模式。看下面v1代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// v1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SerialExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Executor executor;</span><br><span class="line">    <span class="keyword">final</span> Queue&lt;Runnable&gt; queue = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    SerialExecutor(Executor executor) &#123;</span><br><span class="line">        <span class="keyword">this</span>.executor = executor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">        queue.add(() -&gt; &#123;</span><br><span class="line">            r.run();</span><br><span class="line">            <span class="keyword">if</span> (!queue.isEmpty()) &#123;</span><br><span class="line">                Runnable t = queue.poll();</span><br><span class="line">                executor.execute(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于需要串行执行，必然需要有个队列来保存task。这里使用了ArrayDeque。现在来想想execute怎么实现。<code>SerialExecutor</code>只有一个execute提交task的方法，如果在这个方法里面只是将task加入queue末尾然后返回，那么由谁来从queue中取出task并提交内部executor执行呢？另外，一个task执行完成后，又由谁从queue头部取出新的task提交给executor呢？这里的executor不是一个线程池，它只是一个可以执行task的对象，只有一个execute方法，本身内部有可能自带线程，也有可能不带线程而由调用者线程来执行task。</p>
<p>既然不能有独立的线程从队列中依次取出task交由executor执行，那么有个巧妙的方法：每个task执行完自身的事情后，从queue头部取出task，并提交executor执行。也就是，<code>execute(Runnable r)</code>方法里将<code>r</code>再做一次封装，将执行<code>r</code>任务和取队列下一个任务封装在一起，这样就能将队列里面所有的task串起来依次执行。不过上面的v1版本代码有几个问题：</p>
<ol>
<li><code>SerialExecutor</code>不是线程安全的。如果多个线程同时调用<code>SerialExecutor.execute</code>，会有race condition。</li>
<li><code>execute</code>的实现，只是将一个封装task加入队列，并没有交由内部executor执行。如果当前executor已经在执行队列中的task了，那么这个新加入的task会在后续某个时候被poll并被执行；如果当前executor没有在执行呢？就有问题了，队列里面的task没有机会被poll。所以可能需要一个成员变量<code>active</code>标记当前正在执行的task。当active是null的时候，由外部线程在执行<code>execute(r)</code>时从queue中取出task交由内部executor执行。</li>
</ol>
<p>下面是v2版代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// v2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SerialExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Executor executor;</span><br><span class="line">    <span class="keyword">final</span> Queue&lt;Runnable&gt; queue = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    Runnable active;</span><br><span class="line"></span><br><span class="line">    SerialExecutor(Executor executor) &#123;</span><br><span class="line">        <span class="keyword">this</span>.executor = executor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">        queue.add(() -&gt; &#123;</span><br><span class="line">            r.run();</span><br><span class="line">            <span class="keyword">if</span> (!queue.isEmpty()) &#123;</span><br><span class="line">                Runnable t = queue.poll();</span><br><span class="line">                executor.execute(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">if</span> (active == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Runnable t = queue.poll(); <span class="comment">// 上面add了task，队列里肯定有task</span></span><br><span class="line">            active = t;</span><br><span class="line">            executor.execute(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>v2版代码还是有bug的，如果有多个外部线程同时提交任务，只有第一个获取锁的那个线程提交的任务执行完成，其它的都不会执行。为什么？因为<code>execute</code>方法用synchronized进行同步了，第一个获取锁的线程提交任务后，马上执行，并将active设置了，等到自身执行完之后，并没有将active置回null，导致其它线程将任务提交后，并没有交由内部executor执行。再改一版v3如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// v3</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SerialExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Executor executor;</span><br><span class="line">    <span class="keyword">final</span> Queue&lt;Runnable&gt; queue = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    Runnable active;</span><br><span class="line"></span><br><span class="line">    SerialExecutor(Executor executor) &#123;</span><br><span class="line">        <span class="keyword">this</span>.executor = executor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">        queue.add(() -&gt; &#123;</span><br><span class="line">            r.run();</span><br><span class="line">            <span class="keyword">if</span> (!queue.isEmpty()) &#123;</span><br><span class="line">                Runnable t = queue.poll();</span><br><span class="line">                active = t;</span><br><span class="line">                executor.execute(t);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                active = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">if</span> (active == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Runnable t = queue.poll(); <span class="comment">// 上面add了task，队列里肯定有task</span></span><br><span class="line">            active = t;</span><br><span class="line">            executor.execute(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>v3貌似可以work了。但是第14行到20行，写的很粗糙。重写如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((active = queue.poll()) != <span class="keyword">null</span>) &#123; <span class="comment">// 如果Queue是空，Queue.poll返回null，不会阻塞</span></span><br><span class="line">    executor.execute(active);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再仔细看下，v3版代码中有两段重复，应该抽象出一个独立的方法。得到v4版如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// v4</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SerialExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Executor executor;</span><br><span class="line">    <span class="keyword">final</span> Queue&lt;Runnable&gt; queue = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    Runnable active;</span><br><span class="line"></span><br><span class="line">    SerialExecutor(Executor executor) &#123;</span><br><span class="line">        <span class="keyword">this</span>.executor = executor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">        queue.add(() -&gt; &#123;</span><br><span class="line">            r.run();</span><br><span class="line">            scheduleNext();</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">if</span> (active == <span class="keyword">null</span>) &#123;</span><br><span class="line">            scheduleNext();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">scheduleNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// // 如果Queue是空，Queue.poll返回null，不会阻塞</span></span><br><span class="line">        <span class="keyword">if</span> ((active = queue.poll()) != <span class="keyword">null</span>) &#123; </span><br><span class="line">    		executor.execute(active);</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>v4版还有问题么？还有。假如用户提交的任务在运行时出现异常，那么task执行链就会断裂，内部active始终是这个异常的task，导致其它task无法运行。所以，<code>r.run()</code>需要用try包裹一下。得到v5版代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// v5</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SerialExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Executor executor;</span><br><span class="line">    <span class="keyword">final</span> Queue&lt;Runnable&gt; queue = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    Runnable active;</span><br><span class="line"></span><br><span class="line">    SerialExecutor(Executor executor) &#123;</span><br><span class="line">        <span class="keyword">this</span>.executor = executor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">        queue.add(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                r.run();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            	scheduleNext();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">if</span> (active == <span class="keyword">null</span>) &#123;</span><br><span class="line">            scheduleNext();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">scheduleNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// // 如果Queue是空，Queue.poll返回null，不会阻塞</span></span><br><span class="line">        <span class="keyword">if</span> ((active = queue.poll()) != <span class="keyword">null</span>) &#123; </span><br><span class="line">    		executor.execute(active);</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总体来说，Executor比较简单，几个具体实现也简单。不过里面还是有些可以学习的地方。Executor有个问题，用户通过Executor.execute提交任务后，就对任务失去了控制，无法获取到任务处于什么状态（待执行，正在执行，执行异常，执行完成）。用户唯一知道的是，提交的任务在随后的某个时间，可能会被调度执行，仅此而已。而如果想要获取提交的任务的状态，就需要用到ExecutorService接口了。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>线程池</tag>
        <tag>Executor</tag>
        <tag>ExecutorService</tag>
        <tag>JDK11源码</tag>
      </tags>
  </entry>
  <entry>
    <title>Java SDK中线程池系列（三）---- ThreadPoolExecutor</title>
    <url>/2020/06/09/java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ol>
<li>怎么中断一个线程？<ol>
<li>设置一个flag，该线程去check这个flag</li>
<li>向中断线程发送一个中断调用。</li>
</ol>
</li>
<li>依赖倒置原则在java编程中具体表现形式<ol>
<li>类成员变量，申明为接口类型而不是实现类型</li>
<li>类方法参数，声明为接口类型而不是实现类型</li>
<li>类方法返回类型，申明为接口类型而不是实现类型</li>
</ol>
</li>
<li><code>Runnable</code>不是范型类，<code>Callable&lt;T&gt;</code>是泛型类</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>线程池</tag>
        <tag>Executor</tag>
        <tag>ExecutorService</tag>
        <tag>JDK11源码</tag>
      </tags>
  </entry>
  <entry>
    <title>Java SDK中线程池系列（二）---- ExecutorService</title>
    <url>/2020/06/10/java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<p>上一篇讲到Executor接口只有一个提交任务的方法<code>void execute(Runnable r)</code>，用户无法知道任务提交后的状态。这一篇要讲一下ExecutorService接口，它extends Executor，增加了一些接口方法。</p>
<span id="more"></span>

<ol>
<li><p>shutdown/shutdownNow方法，基本的Executor没有提供shutdown方法，一旦被创建，可以无休止的向其提交任务。有了shutdown方法，就可以在不需要的时候停止执行器并随后释放资源。ExecutorService里面的任务有三种状态的：</p>
<ol>
<li>待在队列里，等待被调度执行。</li>
<li>正在被执行。</li>
<li>执行结束或者执行出异常被结束。</li>
</ol>
<p>shutdown和shutdownNow有什么区别呢？shutdown之后，ExecutorService不能再接受新任务了，如果外部用户还向其提交任务，会触发异常。但是内部正在执行的任务以及队列里面等待执行的任务会继续被调度执行。而shutdownNow，顾名思义是立即停止，不能再接受新任务 + 内部队列里的任务被清除 + 尝试中断正在执行的任务。所以，shutdown是优雅停止，而shutdownNow是粗暴停止。</p>
</li>
<li><p>isShutdown/isTerminated，判断当前ExecutorService是否被停止，是否优雅结束了。</p>
</li>
<li><p>awaitTermination，阻塞等待一个优雅停止的ExecutorService完成内部队列里的所有任务。可以加等待超时时间。</p>
</li>
<li><p>submit, 提交任务后，异步返回一个包装的Future。无论提交的任务是Runnable还是Callable，submit系列函数都返回一个Future。用户可以在submit之后，通过这个Future获取任务执行结果。</p>
</li>
<li><p>invokeAll, 批量提交task，然后阻塞式等待所有task执行完成再返回。也可以加超时等待时间。主要此方法接收的task是Callable<T>，而不是Runnable。<strong>为什么</strong>？</T></p>
</li>
<li><p>invokeAny，批量提交task，然后阻塞式等待一个task执行完成后返回。比如一个广告联盟平台场景，平台并发的向多个下游广告供应商请求广告，只要等待最快响应的返回数据就可以了。</p>
</li>
</ol>
<p>JDK里<code>AbstractExecutorService implements ExecutorService</code>，提供上述6类方法中部分的实现。实现了submit, invokeAll, invokeAny。其它的留给子类实现。</p>
<h2 id="submit方法的实现"><a href="#submit方法的实现" class="headerlink" title="submit方法的实现"></a>submit方法的实现</h2><p>ExecutorService.submit可以接收Runnable和Callable<T>，对于Callable<T>，可以将其包装为FutureTask<T>；对于Runnable怎么办，它没有返回值，可以人为的给Runnable设置一个返回值，比如null。</T></T></T></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractExecutorService</span> <span class="keyword">implements</span> <span class="title">ExecutorService</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 为Runnable创建一个FutureTask,用户可以为这个Runnable设置一个dummy的返回值</span></span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Runnable runnable, T value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FutureTask&lt;T&gt;(runnable, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 为Callabe&lt;T&gt;创建一个FutureTask。这里为什么返回RunnableFuture而不返回FutureTask呢？</span></span><br><span class="line">    <span class="comment">// 依赖倒置，更好扩展</span></span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Callable&lt;T&gt; callable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FutureTask&lt;T&gt;(callable);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="keyword">null</span>);</span><br><span class="line">        execute(ftask);</span><br><span class="line">        <span class="keyword">return</span> ftask;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        RunnableFuture&lt;T&gt; ftask = newTaskFor(task, result);</span><br><span class="line">        execute(ftask);</span><br><span class="line">        <span class="keyword">return</span> ftask;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        RunnableFuture&lt;T&gt; ftask = newTaskFor(task);</span><br><span class="line">        execute(ftask);</span><br><span class="line">        <span class="keyword">return</span> ftask;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：ExecutorService不是泛型类，只是有多个泛型方法。</p>
<h2 id="invokeAll方法的实现"><a href="#invokeAll方法的实现" class="headerlink" title="invokeAll方法的实现"></a>invokeAll方法的实现</h2><p>invokeAll方法有两个，其中一个带超时等待时间。用户通过invokeAll批量提交任务，阻塞等待全部完成，或者超时时间到，再返回。如果在超时时间到了后还有任务没有执行，那么就要从队列中清除这些等待执行的任务。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// JDK11里面AbstractExecutorService.invokeAll的实现</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span><br><span class="line">                                     <span class="keyword">long</span> timeout, TimeUnit unit)</span><br><span class="line">    <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (tasks == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> deadline = System.nanoTime() + nanos;</span><br><span class="line">    ArrayList&lt;Future&lt;T&gt;&gt; futures = <span class="keyword">new</span> ArrayList&lt;&gt;(tasks.size());</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    timedOut: <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Callable&lt;T&gt; t : tasks)</span><br><span class="line">            futures.add(newTaskFor(t));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> size = futures.size();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Interleave time checks and calls to execute in case</span></span><br><span class="line">        <span class="comment">// executor doesn&#x27;t have any/much parallelism.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (((i == <span class="number">0</span>) ? nanos : deadline - System.nanoTime()) &lt;= <span class="number">0L</span>)</span><br><span class="line">                <span class="keyword">break</span> timedOut;</span><br><span class="line">            execute((Runnable)futures.get(i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (; j &lt; size; j++) &#123;</span><br><span class="line">            Future&lt;T&gt; f = futures.get(j);</span><br><span class="line">            <span class="keyword">if</span> (!f.isDone()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123; f.get(deadline - System.nanoTime(), NANOSECONDS); &#125;</span><br><span class="line">                <span class="keyword">catch</span> (CancellationException | ExecutionException ignore) &#123;&#125;</span><br><span class="line">                <span class="keyword">catch</span> (TimeoutException timedOut) &#123;</span><br><span class="line">                    <span class="keyword">break</span> timedOut;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> futures;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        cancelAll(futures);</span><br><span class="line">        <span class="keyword">throw</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Timed out before all the tasks could be completed; cancel remaining</span></span><br><span class="line">    cancelAll(futures, j);</span><br><span class="line">    <span class="keyword">return</span> futures;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://dzmiba.com/FutureTask.png" alt="FutureTask"></p>
<p>方法执行逻辑：</p>
<ol>
<li><p>将批量的任务封装成Future<T>。实际是封装成FutureTask<T>，FutureTask是RunnableFuture<T>的实现类。RunnableFuture extends Runnable, Future<V>。</V></T></T></T></p>
</li>
<li><p>依次提交执行, <code>execute((Runnable)futures.get(i))</code>注意这里，做了一下转换。因为execute方法接收的是Runnable。注意，这里的execute方法是留给子类实现的，可以实现成DirectExecutor, ThreadPerTaskExecutor，或者线程池方式，<strong>这个execute方法可能是阻塞的，也可能是非阻塞的</strong>。上面代码中的Line17 ~ Line23行中，有个注释</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Interleave time checks and calls to execute in case</span></span><br><span class="line"><span class="comment">// executor doesn&#x27;t have any/much parallelism.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (((i == <span class="number">0</span>) ? nanos : deadline - System.nanoTime()) &lt;= <span class="number">0L</span>)</span><br><span class="line">         <span class="keyword">break</span> timedOut;</span><br><span class="line">     execute((Runnable)futures.get(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ol>
<p>​        这是什么意思，直译过来是，交叉检查时间且调用execute方法，如果executore没有太多的并行的话。到底        是啥意思呢？依次对每个task包装对象future进行：a. 判断当前时间有没有到达超时时间，如果到达就退出正        常流程，准备返回；b. 对feature进行execute操作。所谓的Interleave time checks是指对每个future进行        execute调用之前先判断一下超时时间是否到达了。如果不这样的做的话，可能得做法是，将队列里面所有的        futures全部执行execute调用后再判断超时时间。很明显，Interleave time checks使得invokeAll方法更加        responsive。如果execute是非阻塞的，可能Interleave time checks没多大作用；但如果execute是阻塞的且        executor并行度不大，那么execute调用就会耗费较多的时间，Interleave time checks作用就大了。</p>
<ol start="3">
<li><p>依次对队列中的future执行get操作，获取task执行结果。</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (; j &lt; size; j++) &#123;</span><br><span class="line">    Future&lt;T&gt; f = futures.get(j);</span><br><span class="line">    <span class="keyword">if</span> (!f.isDone()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123; f.get(deadline - System.nanoTime(), NANOSECONDS); &#125;</span><br><span class="line">        <span class="keyword">catch</span> (CancellationException | ExecutionException ignore) &#123;&#125;</span><br><span class="line">        <span class="keyword">catch</span> (TimeoutException timedOut) &#123;</span><br><span class="line">            <span class="keyword">break</span> timedOut;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ol>
<p>​        看这一段代码，每取出一个future出来后，判断它完成情况。如果没有正常完成，再通过f.get()阻塞等待一段        时间，直到整个invokeAll设置的超时时间到了。在等待过程中，如果task抛异常，通通忽略，留给外部调用        者去处理。如果超时时间到了，用了一个<code>break timedOut</code>，怎么break后面还可以带label吗？是的，类似于        goto，跳出label代码块。这是JDK11的实现。一般来说，代码里面尽量不要有这种goto类型跳跃操作，因为        容易出逻辑错误，还不好调试。JDK8的源码里面，就没有用<code>break timedOut</code>这种实现，而是使用了一个        done标记，所有task都正确完成后，done = true。在finally块判断，如果done是false，就会对任务执行        cancel操作。那为什么JDK11要使用这种<code>break timedOut</code>操作呢，它可以简化代码，对比JDK8和JDK11的代        码，会发现JDK11使用了<code>break timedOut</code>后更清爽。所以想起以前网上有过关于goto的讨论，是否应该在代        码中使用goto。大多数情况下，应该避免使用，不过在有些合适的地方使用goto会大大简化代码。有些编程        语言标准库里就有使用goto的情况。假如在使用goto的时候，知道自己在干什么，可以，否则还是避免使用        它。</p>
<ol start="4">
<li><p>取消还没来得及执行或者没有完成的任务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">     ...</span><br><span class="line">     <span class="comment">// Timed out before all the tasks could be completed; cancel remaining</span></span><br><span class="line">     cancelAll(futures, j);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">cancelAll</span><span class="params">(ArrayList&lt;Future&lt;T&gt;&gt; futures, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> size = futures.size(); j &lt; size; j++)</span><br><span class="line">         futures.get(j).cancel(<span class="keyword">true</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>在第3步，依次取出future进行get操作获取结果时，如果第j个任务正在执行，且等待过程中，到了用户设置的整体超时时间，那么就会进入到<code>cancelAll(futures, j);</code>从第<code>j</code>个任务往后，挨个执行future.cancel的操作。这里要想想，第<code>j</code>个任务执行时超时了，那么第<code>j+1</code>,<code>j+2</code>,…后面的哪些任务可能会处于什么状态呢？有可能还没被调度执行，有可能也在执行中，还有可能执行完成了。为什么？因为这个Executor可能是个线程池Executor，队列里面的任务时并发执行的，每个task的执行时间也是不同的，第<code>j</code>个任务还没执行完，不能说它后面的任务也没完成。再往前一步，假如<code>j+1</code>任务已经完成了，那么对其进行cancel操作，会出现什么情况？没有任务影响。我们可以从下面Future接口的文档看到（下面第一行注释）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Attempts to cancel execution of this task.  This attempt will</span></span><br><span class="line"><span class="comment">     * fail if the task has already completed, has already been cancelled,</span></span><br><span class="line"><span class="comment">     * or could not be cancelled for some other reason. If successful,</span></span><br><span class="line"><span class="comment">     * and this task has not started when &#123;<span class="doctag">@code</span> cancel&#125; is called,</span></span><br><span class="line"><span class="comment">     * this task should never run.  If the task has already started,</span></span><br><span class="line"><span class="comment">     * then the &#123;<span class="doctag">@code</span> mayInterruptIfRunning&#125; parameter determines</span></span><br><span class="line"><span class="comment">     * whether the thread executing this task should be interrupted in</span></span><br><span class="line"><span class="comment">     * an attempt to stop the task.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;After this method returns, subsequent calls to &#123;<span class="doctag">@link</span> #isDone&#125; will</span></span><br><span class="line"><span class="comment">     * always return &#123;<span class="doctag">@code</span> true&#125;.  Subsequent calls to &#123;<span class="doctag">@link</span> #isCancelled&#125;</span></span><br><span class="line"><span class="comment">     * will always return &#123;<span class="doctag">@code</span> true&#125; if this method returned &#123;<span class="doctag">@code</span> true&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mayInterruptIfRunning &#123;<span class="doctag">@code</span> true&#125; if the thread executing this</span></span><br><span class="line"><span class="comment">     * task should be interrupted; otherwise, in-progress tasks are allowed</span></span><br><span class="line"><span class="comment">     * to complete</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> false&#125; if the task could not be cancelled,</span></span><br><span class="line"><span class="comment">     * typically because it has already completed normally;</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> true&#125; otherwise</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;</span><br></pre></td></tr></table></figure>

<p>另外JDK11在这里相比JDK8做了小小的优化。</p>
<p>我们先看看JDK8的实现，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// JDK 8 AbstraceExecutorService的实现</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span><br><span class="line">                                     <span class="keyword">long</span> timeout, TimeUnit unit)</span><br><span class="line">    <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (tasks == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">    ArrayList&lt;Future&lt;T&gt;&gt; futures = <span class="keyword">new</span> ArrayList&lt;Future&lt;T&gt;&gt;(tasks.size());</span><br><span class="line">    <span class="keyword">boolean</span> done = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Callable&lt;T&gt; t : tasks)</span><br><span class="line">            futures.add(newTaskFor(t));</span><br><span class="line">   </span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> deadline = System.nanoTime() + nanos;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> size = futures.size();</span><br><span class="line">   </span><br><span class="line">        <span class="comment">// Interleave time checks and calls to execute in case</span></span><br><span class="line">        <span class="comment">// executor doesn&#x27;t have any/much parallelism.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            execute((Runnable)futures.get(i));</span><br><span class="line">            nanos = deadline - System.nanoTime();</span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>)</span><br><span class="line">                <span class="keyword">return</span> futures;</span><br><span class="line">        &#125;</span><br><span class="line">   </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            Future&lt;T&gt; f = futures.get(i);</span><br><span class="line">            <span class="keyword">if</span> (!f.isDone()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>)</span><br><span class="line">                    <span class="keyword">return</span> futures;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    f.get(nanos, TimeUnit.NANOSECONDS);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (CancellationException ignore) &#123;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ExecutionException ignore) &#123;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (TimeoutException toe) &#123;</span><br><span class="line">                    <span class="keyword">return</span> futures;</span><br><span class="line">                &#125;</span><br><span class="line">                nanos = deadline - System.nanoTime();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        done = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> futures;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 注意这里，如果有任何任务没有正常完成，那么会依次对队列里面每个future执行cancel</span></span><br><span class="line">        <span class="keyword">if</span> (!done)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = futures.size(); i &lt; size; i++)</span><br><span class="line">                futures.get(i).cancel(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从JDK8的代码实现可以看到，如果有任务future任务没有正常完成，会对队列里面每个future执行cancel操作。而JDK11实现是，当迭代到第<code>j</code>个任务到达超时时间了，那么就可以保证前面[0, j-1]的future是正常完成的。那么只需要对[j, size)进行cancel操作即可。</p>
</li>
</ol>
<p>思考：</p>
<ol>
<li>为什么AbstraceExecutorService.invokeAll() 不能批量提交Runnable任务，而必须是Callable<T>任务？StackOverflow上有人回答说，Just found that, <strong>Executors</strong> provides utility method to convert <strong>Runnable</strong> task into a <strong>Callable</strong> task. That explains why we don’t have overloaded <strong>invokeAll</strong> which takes Runnable task as well.链接：<a href="https://stackoverflow.com/questions/24081417/executorservice-invokeall-does-not-support-collection-of-runnable-task">https://stackoverflow.com/questions/24081417/executorservice-invokeall-does-not-support-collection-of-runnable-task</a> 意思是说，用户可以通过Executors.callable(Runnable r)方法将一个Runnable转换为一个Callable，那么JDK里面AbstraceExecutorService就不需要一个重载的invokeAll方法接收Collection<Runnable>批量任务。有点道理。不过如果有个这样的重载方法，用户使用起来会更方便。没有找到官方的解释。</Runnable></T></li>
<li>AbstraceExecutorService.invokeAll()的线程安全性。AbstraceExecutorService是抽象类，没有成员变量，所以它是thread confinement的，是线程安全的。其中保存任务的队列是method confinement的。</li>
</ol>
<h2 id="invokeAny的实现"><a href="#invokeAny的实现" class="headerlink" title="invokeAny的实现"></a>invokeAny的实现</h2><p>这个方法功能是批量提交一堆任务，只要其中一个完成，就返回，并且如果在设定的超时时间到达后，还没有一个任务完成，抛出TimeoutException。如果是我来实现，我怎么做？首先想到的思路是用Object.wait(long timeout)。用户线程将所有任务提交执行后，在一个Object.wait上等待，那些提交的任务一旦完成，就调用Object.notify()，或者设置的等待超时时间到了，用户线程被唤醒，返回结果，或者抛出超时异常。用代码表示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="keyword">for</span> (Callable&lt;T&gt; t : tasks) &#123;</span><br><span class="line">    futures.add(newTaskFor(t, lock));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = futures.size(); i &lt; size; i++) &#123;</span><br><span class="line">    executor.execute(futures.get(i));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等候某个future完成</span></span><br><span class="line">lock.wait();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从future列表中取出done的</span></span><br><span class="line">T result = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = futures.size(); i &lt; size; i++) &#123;</span><br><span class="line">    Future&lt;T&gt; f = futures.get(i);</span><br><span class="line">    <span class="keyword">if</span> (f.isDone()) &#123;</span><br><span class="line">        result = f.get();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        f.cancel();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure>

<p>这段代码有几个问题：</p>
<ol>
<li>第6行，依次对每个future提交给executor执行，即使execute是非阻塞的，很有可能在execute某个future的时候，前面某个future已经完成了。这个时候依然还是将所有future都提交给executor显然是浪费资源，并且没有最快速度返回已经完成的future。</li>
<li>一股脑的将所有future都提交执行，而后再cancel，是不明智的。特别在future任务不能cancel的情况下。</li>
</ol>
<p>JDK11中使用了ExecutorCompletionService来实现这个功能。ExecutorCompletionService是用来干啥的？简单来说，它内部包含了一个Executor，接收批量提交的task，同时对外提供一个take方法—-返回最先执行完成的任务future，还提供了一个poll方法—-有完成的future就返回完成的future，没有就返回null。这个东西，主要是用来解决for循环future.get的问题。for循环future.get有什么问题？fugure.get是阻塞的，从一系列future中依次get的时候，前面未完成的future会挡住后面已经完成的future.get。另有一篇博文详细分析ExecutorCompletionService。现在我们来看看JDK11实现invokeAny的细节。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">T <span class="title">doInvokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tasks == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> ntasks = tasks.size();</span><br><span class="line">    <span class="keyword">if</span> (ntasks == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    ArrayList&lt;Future&lt;T&gt;&gt; futures = <span class="keyword">new</span> ArrayList&lt;&gt;(ntasks);</span><br><span class="line">    ExecutorCompletionService&lt;T&gt; ecs =</span><br><span class="line">        <span class="keyword">new</span> ExecutorCompletionService&lt;T&gt;(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// For efficiency, especially in executors with limited</span></span><br><span class="line">    <span class="comment">// parallelism, check to see if previously submitted tasks are</span></span><br><span class="line">    <span class="comment">// done before submitting more of them. This interleaving</span></span><br><span class="line">    <span class="comment">// plus the exception mechanics account for messiness of main</span></span><br><span class="line">    <span class="comment">// loop.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// Record exceptions so that if we fail to obtain any</span></span><br><span class="line">        <span class="comment">// result, we can throw the last exception we got.</span></span><br><span class="line">        ExecutionException ee = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> deadline = timed ? System.nanoTime() + nanos : <span class="number">0L</span>;</span><br><span class="line">        Iterator&lt;? extends Callable&lt;T&gt;&gt; it = tasks.iterator();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Start one task for sure; the rest incrementally</span></span><br><span class="line">        futures.add(ecs.submit(it.next()));</span><br><span class="line">        --ntasks;</span><br><span class="line">        <span class="keyword">int</span> active = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Future&lt;T&gt; f = ecs.poll();</span><br><span class="line">            <span class="keyword">if</span> (f == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ntasks &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    --ntasks;</span><br><span class="line">                    futures.add(ecs.submit(it.next()));</span><br><span class="line">                    ++active;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (active == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (timed) &#123;</span><br><span class="line">                    f = ecs.poll(nanos, NANOSECONDS);</span><br><span class="line">                    <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">                    nanos = deadline - System.nanoTime();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    f = ecs.take();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (f != <span class="keyword">null</span>) &#123;</span><br><span class="line">                --active;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> f.get();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ExecutionException eex) &#123;</span><br><span class="line">                    ee = eex;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException rex) &#123;</span><br><span class="line">                    ee = <span class="keyword">new</span> ExecutionException(rex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ee == <span class="keyword">null</span>)</span><br><span class="line">            ee = <span class="keyword">new</span> ExecutionException();</span><br><span class="line">        <span class="keyword">throw</span> ee;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        cancelAll(futures);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第14行到17行的注释很重要。”This interleaving plus the exception mechanics account for messiness of main loop”特别是这一句。有一次见到了<strong>interleaving</strong>。交叉检测和异常处理，使得for(;;)循环比较乱。但是效率更高。解释下代码逻辑：</p>
<ol>
<li>创建一个future队列和一个ExecutorCompletionService实例，</li>
<li>设置deadline</li>
<li>提交一个future。</li>
<li>通过ecs.poll判断是否有future已经完成。因为poll是非阻塞的，马上返回。如果有完成的futre，就到53行，return f.get()；将完成的future结果返回了。如果没有完成的，继续取一个新的任务，调到第3步骤。同时判断是否到达deadline，如果到达deadline，抛出TimeoutException。这段代码里面有很多细节要考虑。我们看到代码最后还有个finally块，当有一个任务完成或者超时时间到了的情况下，需要将其它任务取消，否则这些任务浪费资源。</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>线程池</tag>
        <tag>Executor</tag>
        <tag>ExecutorService</tag>
        <tag>JDK11源码</tag>
        <tag>AbstractExecutorService</tag>
      </tags>
  </entry>
</search>
